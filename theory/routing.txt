Все файлы, которые относятся к маршрутизации лежат в папке routes.
Роуты находятся в файле web.php
Можно регистрировать роуты согласно каждому HTTP запросу:
    Route::get($uri, $callback);
    Route::post($uri, $callback);
    Route::put($uri, $callback);
    Route::patch($uri, $callback);
    Route::delete($uri, $callback);
    Route::options($uri, $callback);
Роут может относится одновременно к нескольким запросам:
    Route::match(['get', 'post'], '/', function () {
        //
    });
Есть возможность сделать роут, который сразу делает редирект:
    Route::redirect('/here', '/there');
По умолчанию редирект возвращает код статуса 302, мы можем возвращать свой код, добавив 3-й параметр
    Route::redirect('/here', '/there', 301);
Если наш роут не нуждается в обработке контроллером, мы сразу же можем вернуть view, и там же пробросить
неоходимые данные:
    Route::view('/welcome', 'welcome', ['name' => 'Taylor']);

    Параметры в роутах

Иногда из URL нам необходимо взять какие-либо параметры. В этом случае параметры указываются в фигурных
скобках:
    Route::get('user/{id}', function ($id) {
        return 'User '.$id;
    });
Если мы используем в роуте переход в контроллер и хотим использовать параметр, то в данном случае:
    Route::get('/about/{name}', "MainController@actionAbout")
    //Контроллер public function actionProfile($name)
В контроллере->обработке метода, мы должны будем указать аргумент ($name),
тогда мы сможем его использовать в самом методе.
В роуте мы можем указывать любое кол-во параметров:
    Route::get('posts/{post}/comments/{comment}'...

    Опциональные параметры
Иногда в роуте у нас может быть параметр, а иногда в нем же, параметра может и не быть, в таком случае
мы должны после параметра поставить знак ?.
    Route::get('/about/{name?}', "MainController@actionAbout")
Но в таком случае, необходимо будет в аргументе метода передать значение по-умолчанию
    //Контроллер public function actionProfile($name="anonimus").

    Регулярные выражение в роуте

    В роуте можно указывать ограничения в указании параметра через регулярное выражение
Если параметр не пройжет проверку, то осуществится редирект на 404 страницу.
    Route::get('user/{name}', function ($name) {
        //
    })->where('name', '[A-Za-z]+');

Если мы хотим использовать постоянную проверку параметров, то будет лучше использовать метод boot
В провайдере RouteServiceProvider:
    public function boot()
    {
        Route::pattern('id', '[0-9]+');
        parent::boot();
    }
Как только этот метод будет определен, он будет использоваться для всех параметров с именем id

! В параметрах нельзя использовать слеш "/", но в виде исключения возможно разрешить использование
этого символа через регулрное выражение:
    Route::get('search/{search}', function ($search) {
        return $search;
    })->where('search', '.*');

Обратите внимание, что данный символ можно использовать исключительно в последнем сегменте роута!!!

    Именованные роуты

Мы может давать роутам имена, при помощи метода name.
    Route::view('/',"mainView")->name("main");
После этого, мы может давать значения переменным или использовать роуты в редиректах, используя:
route('main'):

    // Generating URLs...
    $url = route('profile');

    // Generating Redirects...
    return redirect()->route('profile');

Если наш роут содержит параметры, мы их также может передавать вторым параметром:
    Route::get('user/{id}/profile', function ($id) {
        //
    })->name('profile');

    return redirect()->route('profile', ['id' => 1]);

    Группы роутов

Группы роутов позволяют использовать аттрибуты роутов(миддлвейры, неймспейсы)для большой группы роутов
без необходимости укзывать эти аттрибуты для каждого из роутов. Эти аттрибуты указываются в виде массива
первым параметром метода Route::group.

Для указания middleware для группы:
    Route::middleware(['first', 'second'])->group(function () {
        Route::get('/', function () {
            // Uses first & second Middleware
        });

        Route::get('user/profile', function () {
            // Uses first & second Middleware
        });
    });

Для указания namespace для контроллеров:
    Route::namespace('Admin')->group(function () {
        // Controllers Within The "App\Http\Controllers\Admin" Namespace
    });
Запомните, что по-умолчанию RouteServiceProvider включает все ваши файлы роутов в группу неймспейсов
позволяя вам регистриировать контроллер роутов без указания полного префикса App\Http\Controllers.
Но вы можете указать другой специфический неймспейс, который будет следовать после базового App\Http\Controllers.

    Поддоменный роутинг
Группы также могут использоваться для работы с поддоменами. Поддомен может быть указан в методе domain
    Route::domain('{account}.myapp.com')->group(function () {
        Route::get('user/{id}', function ($account, $id) {
            //
        });
    });

    Префикс роутов

Метод "prefix" может быть использован для добавления префикса к URI к каждому роуту в группе.
Для примера, мы может добавить /admin каждому URI в группе:
    Route::prefix('admin')->group(function () {
        Route::get('users', function () {
            // Matches The "/admin/users" URL
        });
    });

    Префикс имен роутов
По аналогии с предыдущим примером, мы может добавлять префиксы к именам роутов в группе:
    Route::name('admin.')->group(function () {
        Route::get('users', function () {
            // Route assigned name "admin.users"...
        })->name('users');
    });

    Байндинг моделей в роутах

Байндинг моделей в роутах Ларавел предлагает удобный путь для автоматического получения экземпляра
модели непосредственно через сам роут. Для примера, в отличие от получения через параметр АЙДИ пользователя
мы можем сразу же получить экземпляр объекта, который соотв параметру АЙДИ переданному через роут.
И потом можно будет обращаться к экземпляру, его св-вам и методам.

    Неявная привязка

    Route::get('api/users/{user}', function (App\User $user) {
        return $user->email;
    });

В этом примере Laravel автоматически внедрит экземпляр модели, который имеет ID,
совпадающий с соответствующим значением из URI запроса, потому что переменная Eloquent $user,
определённая в маршруте, совпадает с сегментом URI маршрута {user}.
Если совпадающий экземпляр модели не найден в базе данных, будет автоматически сгенерирован
HTTP-отклик 404.

По-умолчанию, Ларавел считает, что в параметрах передан АйДи, но можно изменить колонку, для этого
необходимо в модели переписать метод getRouteKeyName модели (Eloquent, от него наследутся все модели).

    public function getRouteKeyName()
    {
        return 'slug';
    }

    Явная привязка

Для явного указания привязки, используйте метод роута - model.
Вам следует определить вашу явную модель привязки в методе boot класса RouteServiceProvider.

public function boot()
{
    parent::boot();

    Route::model('user', App\User::class);
}

Затем определите маршрут, содержащий параметр {user}:

Route::get('profile/{user}', function (App\User $user) {
  //
});

Из-за того, что мы ранее привязали все параметры {user} к модели App\User,
её экземпляр будет внедрён в маршрут.
Таким образом, к примеру, запрос profile/1 внедрит объект User, полученный из БД,
который соответствует ID 1.

Если совпадающий экземпляр модели не найден в базе данных,
будет автоматически сгенерирован HTTP-отклик 404.

    Кастомизация логики

Если вы желаете использовать свою собственную логику, вы можете использовать метод Route::bind.
Переданная в bind функция вернет экземпдяр модели, с примененной к ней логикой, которая вернется в роут.

    public function boot()
    {
        parent::boot();

        Route::bind('user', function ($value) {
            return App\User::where('name', $value)->first() ?? abort(404);
        });
    }

Еще один вариант, это перезапись метода resolveRouteBinding в Eloquent модели. Этот метод получит
значение URI сегмента и вернет экземпляр объекта в роут.

    public function resolveRouteBinding($value)
    {
        return $this->where('name', $value)->first() ?? abort(404);
    }

    Резервные роуты

Используя метод Route::fallback, вы можете определить роут который будет использован, если никакие
роуты не обрабатывают входящий запрос. Как правило необрабатываемые запросы автоматически будут
вызывать 404 страницу. Однако, как только вы определите запасной роут,
все middleware и web middleware группы, примут этот роут. Вы также можете добавлять дополнительные
middleware в этот роут, если необходимо.

    Route::fallback(function () {
        //
    });

!Запасной роут должен быть обязательно последним роутом, зарегистрированным в вашем приложении!

    Ограничение темпа

Ларавел включает в себя  middleware для ограничения лимита доступа в приложении.
Для начала назначьте throttle middleware роуту или группе роутов. throttle middleware принимает
2 параметра которые определяют максимальное кол-во запросов, которые могут быть сделаны за минуту.
Для примера, давайте определм, что пользщователь может стучаться в группу роутов, не более, чем 60
раз в минуту.

    Route::middleware('auth:api', 'throttle:60,1')->group(function () {
        Route::get('/user', function () {
            //
        });
    });

    Динамическое ограничение темпа

Вы можете устанавливать конкретные максимальные значения темпа, основываясь на аттрибутах модели.
Для примера, если ваша модель User содержит rate_limit аттрибут, вы можете пробросить аттрибут
rate_limit в throttle middleware, и он будет использоваться для определения максимального значения.

    Route::middleware('auth:api', 'throttle:rate_limit,1')->group(function () {
        Route::get('/user', function () {
            //
        });
    });

    Подмена метода в форме

ХТМЛ формы не поддерживают методы PUT, PATCH or DELETE. Таким образом, когда вы определяете
PUT, PATCH or DELETE роуты, которые вызываются из формы, вы должны добавить скрытое поле _method в форму
Значение, отраженное в поле _method и будет использовано для НТТР метода.

    <form action="/foo/bar" method="POST">
        <input type="hidden" name="_method" value="PUT">
        <input type="hidden" name="_token" value="{{ csrf_token() }}">
    </form>

Вы также можете использовать @method Blade непосредственно для генерации значения _method

    <form action="/foo/bar" method="POST">
        @method('PUT')
        @csrf
    </form>

    Доступ к текущему роуту

Вы можете использовать current, currentRouteName, and currentRouteAction методы для доступа к информации
о роуте, который обрабатывает входящий запрос.

    $route = Route::current();
    $name = Route::currentRouteName();
    $action = Route::currentRouteAction();

